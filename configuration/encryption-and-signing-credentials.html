<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Encryption and signing credentials </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Encryption and signing credentials ">
    <meta name="generator" content="docfx 2.56.7.0">
    
    <link rel="shortcut icon" href="../images/favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> 
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.png" alt="">
              </a>    </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="encryption-and-signing-credentials">Encryption and signing credentials</h1>

<p>To protect the tokens it issues, OpenIddict uses 2 types of credentials:</p>
<ul>
<li><strong>Signing credentials are used to protect against tampering</strong>. They can be either asymmetric (e.g a RSA or ECDSA key) or symmetric.</li>
<li><strong>Encryption credentials are used to ensure the content of tokens cannot be read by malicious parties</strong>. They can be either asymmetric (e.g a RSA key) or symmetric.</li>
</ul>
<div class="NOTE"><h5>Note</h5><p>Tokens generated using the opt-in ASP.NET Core Data Protection integration rely on their own key ring, distinct from the credentials discussed in this documentation.
For more information about Data Protection, visit <a href="https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/introduction">ASP.NET Core Data Protection</a>.</p>
</div>
<h2 id="registering-credentials-in-the-authorization-server-options">Registering credentials in the authorization server options</h2>
<p>OpenIddict allows registering one or multiple keys (raw keys or embedded in X.509 certificates).</p>
<div class="NOTE"><h5>Note</h5><p>When multiple keys/certificates are registered (which can be useful to implement keys rotation), OpenIddict chooses the most appropriate key based on the following algorithm:</p>
<ul>
<li>Symmetric keys are always chosen first, except for identity tokens, that can only be signed using asymmetric keys.</li>
<li>Asymmetric keys embedded in X.509 certificates are ordered based on the <code>NotAfter</code> and <code>NotBefore</code> dates (certificates that are not yet valid
are not used by OpenIddict and certificates with the furthest expiration date are always preferred).</li>
<li>X.509 certificates are always preferred to raw RSA/ECDSA keys.</li>
</ul>
</div>
<h3 id="registering-an-ephemeral-key">Registering an ephemeral key</h3>
<p>For development purposes, an ephemeral key - that is not persisted or shared across instances - can be used to sign or encrypt tokens:</p>
<pre><code class="lang-csharp">services.AddOpenIddict()
    .AddServer(options =&gt;
    {
        options.AddEphemeralEncryptionKey()
               .AddEphemeralSigningKey();
    });
</code></pre><div class="NOTE"><h5>Note</h5><p><code>options.AddEphemeralEncryptionKey()</code> generates an asymmetric RSA key which is not directly used as-is to encrypt the tokens but is used to encrypt an
intermediate <em>per-token</em> symmetric key with which the token content is first encrypted using <a href="https://datatracker.ietf.org/doc/html/rfc7518#section-5.2.6">AES</a>.
For more information about this mechanism, read <a href="https://datatracker.ietf.org/doc/html/rfc7518#section-4.3">Key Encryption with RSAES OAEP</a>.</p>
</div>
<h3 id="registering-a-development-certificate">Registering a development certificate</h3>
<p>For development purposes, a certificate can be generated and stored by OpenIddict in the certificates store of the user account running the OpenIddict server feature.
Unlike ephemeral keys, development certificates are persisted - but not shared across instances - and will be reused when the application host is restarted.</p>
<pre><code class="lang-csharp">services.AddOpenIddict()
    .AddServer(options =&gt;
    {
        options.AddDevelopmentEncryptionCertificate()
               .AddDevelopmentSigningCertificate();
    });
</code></pre><div class="WARNING"><h5>Warning</h5><p>This feature is not available on .NET Framework 4.6.1: calling <code>options.AddDevelopmentEncryptionCertificate()</code> or <code>options.AddDevelopmentSigningCertificate()</code>
will result in a <code>PlatformNotSupportedException</code> being thrown at runtime if no valid development certificate can be found and a new one must be generated.</p>
</div>
<h3 id="registering-a-key">Registering a key</h3>
<p>To register a signing or encryption key, an instance of a <code>SecurityKey</code> - typically a <code>SymmetricSecurityKey</code> or a <code>RsaSecurityKey</code> -
can be provided to the <code>options.AddSigningKey()</code>/<code>options.AddEncryptionKey()</code> methods:</p>
<pre><code class="lang-csharp">services.AddOpenIddict()
    .AddServer(options =&gt;
    {
        options.AddEncryptionKey(new SymmetricSecurityKey(
            Convert.FromBase64String(&quot;DRjd/GnduI3Efzen9V9BvbNUfc/VKgXltV7Kbk9sMkY=&quot;)));
    });
</code></pre><div class="NOTE"><h5>Note</h5><p>While signing keys can be either symmetric or asymmetric, OpenIddict requires registering at least one asymmetric key to sign identity tokens.
If both an asymmetric and a symmetric signing key are registered, the symmetric key will always be preferred when protecting access tokens,
authorization codes or refresh tokens, while the asymmetric key will be used to sign identity tokens, that are meant to be publicly validated.</p>
</div>
<h3 id="registering-a-certificate-recommended-for-production-ready-scenarios">Registering a certificate (recommended for production-ready scenarios)</h3>
<p>To register a signing or encryption certificate, the <code>options.AddSigningCertificate()</code>/<code>options.AddEncryptionCertificate()</code> methods can be called
with an instance of <code>X509Certificate2</code>. Alternatively, a unique <code>thumbprint</code> identifying the certificate in the machine or user certificate store
of the operating system can also be provided.</p>
<p><strong>In production, it is recommended to use two RSA certificates, distinct from the certificate(s) used for HTTPS: one for encryption, one for signing</strong>.
Certificates can be generated and self-signed locally using the .NET Core <code>CertificateRequest</code> API:</p>
<pre><code class="lang-csharp">using var algorithm = RSA.Create(keySizeInBits: 2048);

var subject = new X500DistinguishedName(&quot;CN=Fabrikam Encryption Certificate&quot;);
var request = new CertificateRequest(subject, algorithm,
    HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
request.CertificateExtensions.Add(new X509KeyUsageExtension(
    X509KeyUsageFlags.KeyEncipherment, critical: true));

var certificate = request.CreateSelfSigned(
    DateTimeOffset.UtcNow,
    DateTimeOffset.UtcNow.AddYears(2));

var data = certificate.Export(X509ContentType.Pfx, string.Empty);
</code></pre><pre><code class="lang-csharp">using var algorithm = RSA.Create(keySizeInBits: 2048);

var subject = new X500DistinguishedName(&quot;CN=Fabrikam Signing Certificate&quot;);
var request = new CertificateRequest(subject, algorithm,
    HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
request.CertificateExtensions.Add(new X509KeyUsageExtension(
    X509KeyUsageFlags.DigitalSignature, critical: true));

var certificate = request.CreateSelfSigned(
    DateTimeOffset.UtcNow,
    DateTimeOffset.UtcNow.AddYears(2));

var data = certificate.Export(X509ContentType.Pfx, string.Empty);
</code></pre><p>The best place to store your certificates will mostly depend on your host:</p>
<ul>
<li>For IIS applications, storing the certificates in the machine store is the recommended option.</li>
<li>On Azure, certificates can be uploaded and exposed to Azure App Services applications using the special <code>WEBSITE_LOAD_CERTIFICATES</code> flag.
For more information, visit <a href="https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-certificate-in-code">https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-certificate-in-code</a></li>
</ul>
<h2 id="importing-credentials-in-the-apiresource-validation-options">Importing credentials in the API/resource validation options</h2>
<h3 id="using-the-optionsuselocalserver-integration">Using the <code>options.UseLocalServer()</code> integration</h3>
<p>When the API and the authorization server are part of the same project, both the signing and
encryption credentials can be easily imported by calling <code>options.UseLocalServer()</code>:</p>
<pre><code class="lang-csharp">services.AddOpenIddict()
    .AddValidation(options =&gt;
    {
        options.UseLocalServer();
    });
</code></pre><h3 id="using-openid-connect-discovery-asymmetric-signing-keys-only">Using OpenID Connect discovery (asymmetric signing keys only)</h3>
<p>When the API and the authorization server are hosted in different applications,
<a href="https://openid.net/specs/openid-connect-discovery-1_0.html">standard OpenID Connect discovery</a> can be used to automatically import asymmetric signing keys:</p>
<pre><code class="lang-csharp">services.AddOpenIddict()
    .AddValidation(options =&gt;
    {
        options.SetIssuer(&quot;https://localhost:44319/&quot;);
        options.UseSystemNetHttp();
    });
</code></pre><h3 id="registering-a-symmetric-signing-key-in-the-token-validation-parameters">Registering a symmetric signing key in the token validation parameters</h3>
<p>Unlike asymmetric signing keys, symmetric keys - used with HMAC-based algorithms like <a href="https://datatracker.ietf.org/doc/html/rfc7518#section-3.2">HS256</a> - cannot
be safely exposed by an OpenID Connect discovery endpoint. As such, they can&#39;t be automatically imported by the OpenIddict validation handler.
For applications that require using a symmetric signing key, the advanced configuration APIs can be used to register it in the token validation options:</p>
<pre><code class="lang-csharp">services.AddOpenIddict()
    .AddValidation(options =&gt;
    {
        options.Configure(options =&gt; options.TokenValidationParameters.IssuerSigningKey =
            new SymmetricSecurityKey(
                Convert.FromBase64String(&quot;DRjd/GnduI3Efzen9V9BvbNUfc/VKgXltV7Kbk9sMkY=&quot;)));
    });
</code></pre><h3 id="registering-an-encryption-key-or-certificate">Registering an encryption key or certificate</h3>
<p>To import an encryption key/certificate, the same overloads as the ones exposed by the OpenIddict server feature can be used:</p>
<pre><code class="lang-csharp">services.AddOpenIddict()
    .AddValidation(options =&gt;
    {
        options.AddEncryptionCertificate(&quot;b82f36609cdaff9a95de60e8d5ac774b2e496c4b&quot;);
    });
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/codeaphex/openiddict-documentation/blob/e79c6f91caf1a614135a289a44cb2238719ab6c6/configuration/encryption-and-signing-credentials.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
